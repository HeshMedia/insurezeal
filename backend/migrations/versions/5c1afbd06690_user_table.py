"""user table

Revision ID: 5c1afbd06690
Revises: 2696e9945151
Create Date: 2025-09-16 13:19:53.444066

"""

from typing import Sequence, Union

import sqlalchemy as sa
from alembic import op
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = "5c1afbd06690"
down_revision: Union[str, None] = "2696e9945151"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Drop indexes first
    try:
        op.drop_index("confirmation_token_idx", table_name="users")
    except:
        pass
    try:
        op.drop_index("email_change_token_current_idx", table_name="users")
    except:
        pass
    try:
        op.drop_index("email_change_token_new_idx", table_name="users")
    except:
        pass
    try:
        op.drop_index("reauthentication_token_idx", table_name="users")
    except:
        pass
    try:
        op.drop_index("recovery_token_idx", table_name="users")
    except:
        pass
    try:
        op.drop_index("users_email_partial_key", table_name="users")
    except:
        pass
    try:
        op.drop_index("users_instance_id_email_idx", table_name="users")
    except:
        pass
    try:
        op.drop_index("users_instance_id_idx", table_name="users")
    except:
        pass
    try:
        op.drop_index("users_is_anonymous_idx", table_name="users")
    except:
        pass

    # Drop dependent computed column first
    try:
        op.drop_column("users", "confirmed_at")
    except:
        pass

    # Drop unique constraint indexes that might exist
    try:
        op.execute("DROP INDEX IF EXISTS confirmation_token_unique_non_null")
    except:
        pass
    try:
        op.execute("DROP INDEX IF EXISTS email_change_token_current_unique_non_null")
    except:
        pass
    try:
        op.execute("DROP INDEX IF EXISTS email_change_token_new_unique_non_null")
    except:
        pass
    try:
        op.execute("DROP INDEX IF EXISTS reauthentication_token_unique_non_null")
    except:
        pass
    try:
        op.execute("DROP INDEX IF EXISTS recovery_token_unique_non_null")
    except:
        pass

    # Drop columns
    columns_to_drop = [
        "instance_id",
        "phone_change_sent_at",
        "email_change_sent_at",
        "last_sign_in_at",
        "is_anonymous",
        "raw_app_meta_data",
        "email_change",
        "reauthentication_token",
        "reauthentication_sent_at",
        "invited_at",
        "email_change_token_current",
        "recovery_token",
        "email_change_confirm_status",
        "banned_until",
        "email_confirmed_at",
        "phone_change",
        "phone_change_token",
        "email_change_token_new",
        "is_sso_user",
        "encrypted_password",
        "recovery_sent_at",
        "confirmation_token",
        "aud",
        "raw_user_meta_data",
        "is_super_admin",
        "phone_confirmed_at",
        "confirmation_sent_at",
    ]

    for column in columns_to_drop:
        try:
            op.drop_column("users", column)
        except:
            pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column(
        "users",
        sa.Column(
            "confirmation_sent_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "phone_confirmed_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column("is_super_admin", sa.BOOLEAN(), autoincrement=False, nullable=True),
    )
    op.add_column(
        "users",
        sa.Column(
            "raw_user_meta_data",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column("aud", sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    )
    op.add_column(
        "users",
        sa.Column(
            "confirmation_token",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "recovery_sent_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "encrypted_password",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "confirmed_at",
            postgresql.TIMESTAMP(timezone=True),
            sa.Computed(
                "LEAST(email_confirmed_at, phone_confirmed_at)", persisted=True
            ),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "is_sso_user",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=False,
            comment="Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.",
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "email_change_token_new",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "phone_change_token",
            sa.VARCHAR(length=255),
            server_default=sa.text("''::character varying"),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "phone_change",
            sa.TEXT(),
            server_default=sa.text("''::character varying"),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "email_confirmed_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "banned_until",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "email_change_confirm_status",
            sa.SMALLINT(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "recovery_token", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "email_change_token_current",
            sa.VARCHAR(length=255),
            server_default=sa.text("''::character varying"),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "invited_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "reauthentication_sent_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "reauthentication_token",
            sa.VARCHAR(length=255),
            server_default=sa.text("''::character varying"),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "email_change", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "raw_app_meta_data",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "is_anonymous",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=False,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "last_sign_in_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "email_change_sent_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users",
        sa.Column(
            "phone_change_sent_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "users", sa.Column("instance_id", sa.UUID(), autoincrement=False, nullable=True)
    )
    op.create_index("users_is_anonymous_idx", "users", ["is_anonymous"], unique=False)
    op.create_index("users_instance_id_idx", "users", ["instance_id"], unique=False)
    op.create_index(
        "users_instance_id_email_idx", "users", ["instance_id"], unique=False
    )
    op.create_index("users_email_partial_key", "users", ["email"], unique=False)
    op.create_index("recovery_token_idx", "users", ["recovery_token"], unique=False)
    op.create_index(
        "reauthentication_token_idx", "users", ["reauthentication_token"], unique=False
    )
    op.create_index(
        "email_change_token_new_idx", "users", ["email_change_token_new"], unique=False
    )
    op.create_index(
        "email_change_token_current_idx",
        "users",
        ["email_change_token_current"],
        unique=False,
    )
    op.create_index(
        "confirmation_token_idx", "users", ["confirmation_token"], unique=False
    )
    # ### end Alembic commands ###
